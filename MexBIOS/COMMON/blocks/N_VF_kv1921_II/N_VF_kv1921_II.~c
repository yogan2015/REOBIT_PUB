 
#ifdef __BORLANDC__
#define _FUNC_CALL_  __stdcall
#else
#ifndef _FUNC_CALL_
#define _FUNC_CALL_  
#endif
#endif
 
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <float.h>
#include "IQmathLib.h"
#include "chip.h"
 
#include "kernel.h"
extern struct MBS_KERNEL Kernel;
#define MBS_getData(Addr)                      MBS_getGlobalData(&Kernel, Addr)
#define MBS_setData(Addr, Data, Flag)          MBS_setGlobalData(&Kernel, Addr, Data, Flag)
#define MBS_getPjtData(Addr, Len)              MBS_getProjectData(&Kernel, Addr, Len)
#define MBS_setPjtData(Addr, Data, Flag, Len)  MBS_setProjectData(&Kernel, Addr, Data, Flag, Len)
#define MBS_getMemSt()                         MBS_getMemStatus(&Kernel)
 
extern float SimulationTime;
 
#ifndef M_PI
#define M_PI    3.14159265358979323846
#endif
 
typedef struct _N_VF_kv1921_II_STR {
  float  *Magn;
  float  *Cos_1;
  float  *Sin_1;
  float  *f_basic;
  long   *RST;
  float   freq;
  long    Cos;
  long    Sin;
  float   Alpha;
  float   Beta;
  float   Td;
  float   K_i;
  float   K_p;
  float   g1;
  float   e1;
  float   ccnt;
  float   UI_Max;
  float   UI_Min;
} N_VF_kv1921_II_STR;
 

// Do not initialize inputs!
void _FUNC_CALL_ MBS_N_VF_kv1921_II_Init(N_VF_kv1921_II_STR *v)
{

}

void _FUNC_CALL_ MBS_N_VF_kv1921_II_Exec(N_VF_kv1921_II_STR *v)
{
  float dpi=6.28318;
  float g, gc, e;
  int Cos_IN, Sin_IN, Cos_OUT, Sin_OUT, delt;

//  выходные значения по двухфазной системе расчитываются исходя из текущего значения циклического счетчика
Cos_OUT = _IQ24cos(__IQ(v->ccnt,24));
Sin_OUT = _IQ24sin(__IQ(v->ccnt,24));

Cos_IN = __IQ((*v->Cos_1/ *v->Magn),24);
Sin_IN = __IQ((*v->Sin_1/ *v->Magn),24);
delt = _IQ24mpy(Cos_OUT, Sin_IN) - _IQ24mpy(Sin_OUT, Cos_IN);

//  Разность фаз подается на вход ПИ-регулятора
e = _IQ24toF(delt);


gc = v->g1 + v->K_p * (e - v->e1) + v->K_i * v->Td * e;
if (gc>=v->UI_Max) gc = v->UI_Max;
if (gc<=v->UI_Min) gc = v->UI_Min;

g = gc;
if (*v->RST)  g = 0;


//  циклический счетчик приращается пропорционально f_basic (+ g), где g - выход ПИ-регулятора, поправка опорной частоты
if (*v->RST){
  v->ccnt += ((*v->f_basic * dpi) * v->Td);
} else {
  v->ccnt += ((*v->f_basic * dpi + g) * v->Td);
}
if (v->ccnt > dpi) v->ccnt -= (dpi);
if (v->ccnt < 0) v->ccnt += (dpi);

v->g1 = g;
v->e1 = e;
v->freq = g / dpi + *v->f_basic;

//  выходы
v->Cos = Cos_OUT;
v->Sin = Sin_OUT;
v->Alpha = _IQ24toF(Cos_OUT) * *v->Magn;
v->Beta = _IQ24toF(Sin_OUT) * *v->Magn;
}


/******************************************************************************
 * @file		main.c
 * @brief		Главный файл проекта
 * @version		v1.0
 * @date		11 декабря 2015
 *
 * @note
 * ООО "НПФ Вектор" (http://motorcontrol.ru), все права защищены.
 *
 * @par
 * ООО "НПФ Вектор" распространяет это программное обеспечение в демонстрационных
 * целях, и оно может распространяться свободно.
 *
 * @par
 * Данное программное обеспечение распространяется "как есть", и Вы,
 * его пользователь, принимаете на себя все риски, связанные с его использованием.
 * ООО "НПФ Вектор" не несет никакой ответственности за возможные убытки,
 * связанные с его использованием.
 *
 ******************************************************************************/

//В этом примере показана работа с таймерами общего назначения и прерываниями микроконтроллера.
//Вначале инициализируется периферия для управления светодиодами, затем инициализируются таймеры и
//настраиваются прерывания, после чего программа попадает в бесконечный фоновый цикл, в котором ничего не делается.
//Прерывание с частотой 10 кГц (таймер 0) имеет более высокий приоритет, чем прерывание с частотой 1 кГц (таймер 1).
//Т.е., процедура обработки прерывания по таймеру 1 может быть приостановлена для обработки прерывания по таймеру 0.
//В конце приведены примеры процедур обработки прерываний по таймерам. В данном случае в этих процедурах
//производится включение/выключение светодиодов. В отличие от переключения светодиодов в фоновом цикле,
//работа в прерывании четко привязана к тактированию, т.е. при изменении опций оптимизации кода частота
//мигания диодов не меняется.

#include "DSP.h"
#include "main.h"
#include <string.h>	//для memcpy


//Макросы для включения/выключения светодиодов на плате ControlCARD
//Можно использовать команды вида NT_GPIOC->DATA &= ~(1 << 2) и NT_GPIOC->DATA |= (1 << 2), но
//таким образом порты меняют состояние не сразу, а через 2 такта (это связано с синхронизацией), и, если
//подряд написать 2 строчки, например NT_GPIOC->DATA &= ~(1 << 2) и NT_GPIOC->DATA &= ~(1 << 3), то первая
//с большой вероятностью не сработает, так как доступ к биту осуществляется сначала чтением всего слова, изменением нужного
//бита и записью его назад. Но чтение из GPIO возвращает текущее состояние порта, и к моменту выполнения второй команды (второй строки Си)
//прочитанное состояние не будет содержать изменений, которые сделала первая команда, поэтому вторая команда затрет тот бит,
//который хотела выставить первая команда.
//При этом проблема проявляется только при включенной высокой оптимизации компилятора. Без оптимизации компилятор генерирует
//достаточно много ассемблерных команд между обращениями к GPIO и синхронизация успевает выполниться.

//Другой способ - обращение к GPIO по маске (см. документацию): MASKLOWBYTE - к младшему байту регистра, MASKHIGHBYTE - к старшему.
//Допустим, мы хотим выдать "1" на GPIO2, GPIO3 и GPIO4 порта C:
//0001 1100		маска, является индексом в массиве MASKLOWBYTE
//xxx1 11xx		записываемое значение: в нужных битах - единицы, в остальных - не важно, т.к. они не попадают в маску и не будут изменены
//NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 28;	так выглядит код команды, как вариант: NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 0xFF;
//если надо включить GPIO2 и GPIO4 и выключить GPIO3, то:
//NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 20;	20 = 0001 0100b
//Доступ к битам порта по маске гарантирует, что другие биты, которые не попадают в маску, будут не затронуты.
//Также доступ по маске позволяет одновременно одной командой переключить два бита порта, если это требуется.

#define VD1_ON NT_GPIOC->MASKLOWBYTE_bit[8].MASKLB = 0			//NT_GPIOC->DATA &= ~(1 << 3)
#define VD1_OFF NT_GPIOC->MASKLOWBYTE_bit[8].MASKLB = 8			//NT_GPIOC->DATA |= (1 << 3)

#define VD2_ON NT_GPIOC->MASKLOWBYTE_bit[4].MASKLB = 0			//NT_GPIOC->DATA &= ~(1 << 2)
#define VD2_OFF NT_GPIOC->MASKLOWBYTE_bit[4].MASKLB = 4			//NT_GPIOC->DATA |= (1 << 2)

#define VD3_ON NT_GPIOB->MASKLOWBYTE_bit[32].MASKLB = 0			//NT_GPIOB->DATA &= ~(1 << 5)
#define VD3_OFF NT_GPIOB->MASKLOWBYTE_bit[32].MASKLB = 32		//NT_GPIOB->DATA |= (1 << 5)

#define VD4_ON NT_GPIOB->MASKLOWBYTE_bit[64].MASKLB = 0			//NT_GPIOB->DATA &= ~(1 << 6)
#define VD4_OFF NT_GPIOB->MASKLOWBYTE_bit[64].MASKLB = 64		//NT_GPIOB->DATA |= (1 << 6)

#define VD5_ON NT_GPIOB->MASKLOWBYTE_bit[128].MASKLB = 0		//NT_GPIOB->DATA &= ~(1 << 7)
#define VD5_OFF NT_GPIOB->MASKLOWBYTE_bit[128].MASKLB = 128		//NT_GPIOB->DATA |= (1 << 7)

#define VD6_ON NT_GPIOB->MASKHIGHBYTE_bit[1].MASKHB = 0			//NT_GPIOB->DATA &= ~(1 << 8)
#define VD6_OFF NT_GPIOB->MASKHIGHBYTE_bit[1].MASKHB = 1		//NT_GPIOB->DATA |= (1 << 8)

//Глобальная переменная периода счета таймера (может быть изменена при остановке расчета в окне просмотра переменных)
int TimerPeriod = 1000;


//Функция инициализации дискретных выходов микроконтроллера для управления светодиодами
void LED_init (void)
{
	//Для каждой дискретной ножки нужно:
	//1)Выключить привязанные к этой ножке спецфункции путем сброса соответствующего бита в регистре спецфункций порта.
	//Для сброса бита нужно записать "1" в соответствующий бит регистра ALTFUNCCLR (CLR - clear - очистить).
	//Если нужно наоборот включить спецфункцию, то следует записать "1" в соответствующий бит регистра ALTFUNCSET (SET - установить).
	//Прочитать текущее состояние регистра спецфункций порта можно, прочитав любой из двух регистров ALTFUNCCLR или ALTFUNCSET.
	//2)Разрешить ножке работать на вывод путем записи "1" в соответствующий бит регистра OUTENSET.
	NT_GPIOC->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 2);
	NT_GPIOC->OUTENSET_bit.OUTENSET |= (1 << 2);
	NT_GPIOC->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 3);
	NT_GPIOC->OUTENSET_bit.OUTENSET |= (1 << 3);
	NT_GPIOB->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 5);
	NT_GPIOB->OUTENSET_bit.OUTENSET |= (1 << 5);
	NT_GPIOB->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 6);
	NT_GPIOB->OUTENSET_bit.OUTENSET |= (1 << 6);
	NT_GPIOB->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 7);
	NT_GPIOB->OUTENSET_bit.OUTENSET |= (1 << 7);
	NT_GPIOB->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 8);
	NT_GPIOB->OUTENSET_bit.OUTENSET |= (1 << 8);
	//Почему команды NT_GPIOC->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 2); и NT_GPIOC->OUTENSET_bit.OUTENSET |= (1 << 2); отличаются,
	//ведь они выполняют по сути одну и ту же операцию: изменение 2-го бита (если считать от нуля) в регистре?
	//Дело в том, что для записи одного бита в регистр он сначала читается целиком,
	//затем выставляется "1" во втором бите, остальные не меняются, и регистр записывается обратно целиком.
	//По команде ALTFUNCCLR = (1 << 2) в регистр будут записаны все нули и "1" во втором бите.
	//Разница состоит в том, что при чтении регистров OUTENSET и ALTFUNCCLR "1" и там и там означет включенную
	//работу ножки на вывод или альтернативную функцию, соответственно. НО! При записи "1" в OUTENSET происходит включение
	//ножки на вывод, а в ALTFUNCCLR - вЫключение альт. функции. Рассмотрим пример:
	//NT_GPIOC->OUTENSET_bit.OUTENSET |= (1 << 7);
	//0000 1100 0000 1111			исходное состояние: пусть были включены на вывод ножки 0-3 и 10-11
	//0000 1100 0000 1111			чтение регистра целиком
	//0000 1100 1000 1111			добавление "1" в 7-й бит
	//0000 1100 1000 1111			запись регистра целиком
	//0000 1100 1000 1111			результат: включены все ножки, что и в исходном состоянии + 7-я, как и требовалось
	//NT_GPIOC->ALTFUNCCLR_bit.ALTFUNCCLR |= (1 << 7);
	//0000 1100 1000 1111			исходное состояние: пусть были включены альт. функции ножек 0-3, 7 и 10-11
	//0000 1100 1000 1111			чтение регистра целиком
	//0000 1100 1000 1111			добавление "1" в 7-й бит (т.к. альт. функция была включена, состояние регистра не изменилось)
	//0000 1100 1000 1111			запись регистра целиком
	//0000 0000 0000 0000			результат: выключены все ножки, т.к. при чтении "1" означает включенное состояние, а при записи "1" означает команду "выключить"
	//NT_GPIOC->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 7);	чтобы добиться желаемого результата, нужно записать "1" только в 7-й бит и "0" - во все остальные:
	//0000 1100 1000 1111			исходное состояние: пусть были включены альт. функции ножек 0-3, 7 и 10-11
	//0000 1100 1000 1111			чтение регистра целиком
	//0000 0000 1000 0000			запись "1" в 7-й бит и "0" в остальные
	//0000 0000 1000 0000			запись регистра целиком
	//0000 1100 0000 1111			результат: выключена только требуемая ножка, как и требовалось
	//Аналогичная ситуация может быть и с остальными регистрами типа SET и CLR. Подробнее - см. документацию на микроконтроллер, как
	//работают соответствующие регистры на чтение.
}


void Timer_and_interrupt_init (void)
{
	volatile uint32_t priority;
	volatile uint32_t priorityGroup;

    extern int *g_pfnVectors;//Указатель на массив векторов прерываний, объявлен в startup_MCP_gcc.s
    //Надо показать в регистре SCB->VTOR, где лежит таблица прерываний.
    //А лежит она там, куда записал её линкер, в зависимости от файла компоновки.
    //Поэтому берем адрес от массива g_pfnVectors и кладем туда
    SCB->VTOR = (uint32_t)(&g_pfnVectors);//Sets the vector table location and Offset.

    DINT;	//запретить все прерывания

	//Настраиваем группировку прерываний. Значение "4" означает, что будет использовано 8 групп и 2 подгруппы.
    //Чем меньше номер группы или подгруппы, тем выше приоритет прерываний в ней.
    //Прерывания по группам работают с "вытеснением", а по подгруппам - без "вытеснения".
    //Пример. Если во время обработки прерывания группы 5 возник запрос на обработку прерывания группы 2, то
    //начнется процедура обработки прерывания группы 2, а после его завершения процессор продолжит
    //обработку прерывания группы 5. Если во время обработки прерывания ПОДгруппы 1 возник запрос на обработку
    //прерывания ПОДгруппы 0 (внутри одной группы), то процессор продолжит обработку прерывания "1" и только
    //после ее завершения перейдет к обработке прервыания "0". Если же запросы на обработку прерываний
    //ПОДгрупп 0 и 1 возникли одновременно, то первым обработается прерывание ПОДгруппы 0.
    NVIC_SetPriorityGrouping(4);	//В данном процессоре под группы/подгруппы отведено только 3 бита, т.е. будет 8 групп и 0 подгрупп

    priorityGroup = NVIC_GetPriorityGrouping();	//прочитаем группировку прерываний для дальнейшего пользования

    //запретим прерывания от таймеров общего назначения 0 и 1
    NVIC_DisableIRQ(TIM0_IRQn);
    NVIC_DisableIRQ(TIM1_IRQn);
    //и сбросим "висящие" флаги этих прерываний
    NVIC_ClearPendingIRQ(TIM0_IRQn);
    NVIC_ClearPendingIRQ(TIM1_IRQn);

    //Настроим прерывание таймера 0
    NVIC_EnableIRQ(TIM0_IRQn);											//разрешим
    priority = NVIC_EncodePriority(priorityGroup, IRQ_PRIORITY_10K, 0); //кодирование приоритета
    NVIC_SetPriority(TIM0_IRQn,priority);								//задание приоритета
    //Настроим прерывание таймера 1 (аналогично)
    NVIC_EnableIRQ(TIM1_IRQn);
    priority = NVIC_EncodePriority(priorityGroup, IRQ_PRIORITY_1K, 0);
    NVIC_SetPriority(TIM1_IRQn,priority);

    //Настройка таймеров
    //Настройка таймера 0 на 10 кГц
    NT_TIMER0->INTSTATUS_INTCLEAR_bit.INT = 1;		//очистка флага прерывания таймера
    NT_TIMER0->RELOAD = 10000-1;					//Частота тактирования - 100 МГц. Период таймера - 100000кГц/10кГц = 10000. 10000-1 пишется, т.к. таймер считает с нуля.
    NT_TIMER0->CTRL = ( (1 << 0) | (1 << 3) );		//Запуск таймера (нулевой бит регистра CTRL) и разрешение прерываний (третий бит)
    //Настройка таймера 1 на 1 кГц (аналогично)
    NT_TIMER1->INTSTATUS_INTCLEAR_bit.INT = 1;
    NT_TIMER1->RELOAD = 100000-1;
    NT_TIMER1->CTRL = ( (1 << 0) | (1 << 3) );

    EINT;	//Разрешить прерывания
}


int16 main (void){
	//Инициализация микроконтроллера: настройка таймеров, инициализаци периферийных устройств
	InitCLK();
	//копируем функции секции fastcode из флеша в оперативку
	memcpy(&__fastcode_ram_start, &__fastcode_flash_start,((Uint32)(&__fastcode_ram_end) - (Uint32)(&__fastcode_ram_start)));
	//копируем таблицу векторов прерываний isr_vector из флеша в оперативку, чтобы быстрее работало
	memcpy(&__isr_vector_ram_start, &__isr_vector_flash_start,((Uint32)(&__isr_vector_ram_end) - (Uint32)(&__isr_vector_ram_start)));

	//Инициализация периферии для управления диодами
	LED_init();

	//Инициализация таймеров общего назначения и прерываний
	Timer_and_interrupt_init();

	//бесконечный цикл
	while(1)
	{
		;
	}
}

//Процедуры обработки прерываний
//Таймер 1 (1 кГц)
void TIM1_IRQHandler (void)
{
	static int Timer1K;
	Timer1K++;
	//1й светодиод горит 1000 циклов таймера с периодом 1 мс (1 секунду) и не горит 1000 циклов
	if (Timer1K > 2*TimerPeriod)
	{
		VD1_OFF;
		Timer1K = 0;
	}
	else if (Timer1K > TimerPeriod)
	{
		VD1_ON;
	}

	NT_TIMER1->INTSTATUS_INTCLEAR_bit.INT = 1;	//Сбросим флаг прерывания таймера
}

//Таймер 0 (10 кГц)
//__attribute__((section(".fastcode")))  //этот атрибут можно использовать для указания gcc поместить этот код в оперативку
//для увеличения производительности, если программа собрана для флеша. Но - как показали тесты, из оперативки получается не сильно быстрее, а порой даже медленее.
void TIM0_IRQHandler (void)
{
	static int Timer10K;
	Timer10K++;
	//диоды с 2го по 6й зажигаются по очереди на 1000 циклов таймера с периодом 0.1 мс (на 0.1 секунду)
	//полный цикл составляет 0.5 секунды
	if (Timer10K > 5*TimerPeriod)
	{
		VD6_ON;
		VD5_OFF;
		Timer10K = 0;
	}
	else if (Timer10K > 4*TimerPeriod)
	{
		VD5_ON;
		VD4_OFF;
	}
	else if (Timer10K > 3*TimerPeriod)
	{
		VD4_ON;
		VD3_OFF;
	}
	else if (Timer10K > 2*TimerPeriod)
	{
		VD3_ON;
		VD2_OFF;
	}
	else if (Timer10K > TimerPeriod)
	{
		VD2_ON;
		VD6_OFF;
	}

	NT_TIMER0->INTSTATUS_INTCLEAR_bit.INT = 1;	//Сбросим флаг прерывания таймера
}


/*@}*/


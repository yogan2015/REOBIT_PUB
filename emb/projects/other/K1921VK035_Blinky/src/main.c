/******************************************************************************
 * @file		main.c
 * @brief		Главный файл проекта
 * @version		v1.0
 * @date		25 июля 2019
 *
 * @note
 * ООО "НПФ Вектор" (http://motorcontrol.ru), все права защищены.
 *
 * @par
 * ООО "НПФ Вектор" распространяет это программное обеспечение в демонстрационных
 * целях, и оно может распространяться свободно.
 *
 * @par
 * Данное программное обеспечение распространяется "как есть", и Вы,
 * его пользователь, принимаете на себя все риски, связанные с его использованием.
 * ООО "НПФ Вектор" не несет никакой ответственности за возможные убытки,
 * связанные с его использованием.
 *
 ******************************************************************************/

//В этом примере показана работа с дискретными ножками микроконтроллера.
//Вначале производится инициализация нож для работы в режиме дискретного вывода.
//Затем программа попадает в бесконечный цикл, где с задержкой, задаваемой в переменной TimerPeriod,
//по одному из алгоритмов включаются и выключаются 6 светодиодов.
//Описаны некоторые "подводные камни" при работе с регистрами периферии.

#include "main.h"

// Макросы для выбора способа переключения светодиода (нужно раскомментировать один из них)
//#define TOGGLE_BY_MASK              0
//#define TOGGLE_BY_DATAOUTSET_CLR    1
//#define TOGGLE_BY_DATATOGGLE        2
#define TOGGLE_BY_DATA              3

//Глобальная переменная периода счета таймера (может быть изменена при остановке расчета в окне просмотра переменных)
int TimerPeriod = 500000;


// Глобальная переменная для хранения состояния светодиода
int ledState = 0;


//Функция инициализации дискретных выходов микроконтроллера для управления светодиодами
void LED_init (void)
{
	// Для примера используется вывод 12 разъёма X3
    // 1) Разрешить его работу, записав "1" в соответствующий бит (бит №3) регистра DENSET. После этого вывод начнёт функционировать.
    //    по умолчанию в соответствии с документации он играет роль ввода-вывода общего назначения (управляется программой, а не
    //    каким-либо периферийным устройством) и настроен на _приём_ сигнала, а не на выдачу
    // 2) Вывод A3 переводится в режим _выдачи_ сигналов записью "1" в соответствующий бит регстра OUTENSET. По умолчанию, значение
    //    выхода равно "0", поэтому вывод А3 примет состояние "0".
    GPIOA->DENSET = (1 << 13);
	GPIOA->OUTENSET = (1 << 13);
	GPIOA->ALTFUNCCLR = (1 << 13);
}



//Функция мигания светодиодом
void LED_blink (void)
{
	static int timer;	//переменная таймера

	if (timer > TimerPeriod)
	{
		timer = 0;
		ledState ^= 0x1;

#ifdef TOGGLE_BY_MASK
		// Способ 1. Обращение к GPIO по маске (см. документацию): MASKLOWBYTE - к младшему байту регистра, MASKHIGHBYTE - к старшему.
		//Допустим, мы хотим выдать "1" на GPIO2, GPIO3 и GPIO4 порта C:
		//0001 1100     маска, является индексом в массиве MASKLOWBYTE
		//xxx1 11xx     записываемое значение: в нужных битах - единицы, в остальных - не важно, т.к. они не попадают в маску и не будут изменены
		//NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 28;    так выглядит код команды, как вариант: NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 0xFF;
		//если надо включить GPIO2 и GPIO4 и выключить GPIO3, то:
		//NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 20;    20 = 0001 0100b
		//Доступ к битам порта по маске гарантирует, что другие биты, которые не попадают в маску, будут не затронуты.
		//Также доступ по маске позволяет одновременно одной командой переключить два бита порта, если это требуется.
		if (ledState == 0x1)
		    GPIOA->MASKLB[1 << 13].MASKLB = 1 << 13;
		else
		    GPIOA->MASKLB[1 << 13].MASKLB = 0;

#endif

#ifdef TOGGLE_BY_DATAOUTSET_CLR
		//Способ 2 (нужно раскомментировать макрос TOGGLE_BY_DATAOUTSET_CLR в начале файла, и закомментировать остальные)
		// После записи "1" в один из битов регистра DATAOUTSET, соответствующая ножка принимает состояние "1", независимо
		// от предыдущего состояния.
        // После записи "1" в один из битов регистра DATAOUTCLR, соответствующая ножка принимает состояние "0", независимо
        // от предыдущего состояния.
		// Важное примечание: при чтении эти регистры возвращают то значение, которое было записано в предыдущий раз.
        // Поэтому в те биты, которые НЕ должны менять своё состояние, обязательно нужно записать нули. То есть запись через
        // операцию побитового ИЛИ (например DATAOUTSET |= (1 << 13) ) недопустима, так как при этом будет считано значение
        // регистра DATAOUTSET, в прочитанном значении будет взведётся 8 бит и получившееся значение будет записано обратно. Это
        // приведёт к включению всех выводов, соответствующие биты которых были равны "1". Аналогично для DATAOUTCLR.
		// Пример:
		// При старте программы регистр DATAOUTSET равен "0000 0000 0000 0000"
		// В каком-то месте программы  был включен 4 вывод командой DATAOUTSET |= (1 << 4): прочитано значение "0000 0000 0000 0000",
		// изменён 4 бит, получившееся значение записано обратно. Теперь DATAOUTSET равен "0000 0000 0001 0000".
		// Затем вывод был выключен командой DATAOUTCLR |= (1 << 4).
		// Значение регистра DATAOUTSET при этом не изменилось: DATAOUTSET равен "0000 0000 0001 0000"
		// Затем пользователь захотел включить 8 вывод порта командой DATAOUTSET |= (1 << 13).
		// Теперь после чтения DATAOUTSET и изменения 8 бита, в него будет записано значение "0000 0001 0001 0000", что
		// приведёт к включению и 4, и 8 выводов.
		if (ledState == 0x1)
			GPIOA->DATAOUTSET = (1 << 13);
		else
			GPIOA->DATAOUTCLR = (1 << 13);

#endif

#ifdef TOGGLE_BY_DATATOGGLE
        //Алгоритм 3 (нужно раскомментировать макрос TOGGLE_BY_DATATOGGLE в начале файла, и закомментировать остальные)
        // Запись "1" в один из битов регистра DATAOUTTGL меняет состояние соответсвующих ножек на противоположное.
		// При этом в те биты, которые НЕ должны переключаться, обязательно нужно записать нули. То есть запись через
		// операцию побитового ИЛИ (например DATAOUTTGL |= (1 << 13) ) недопустима, так как при этом будет считано значение
		// регистра TGL, в прочитанном значении будет взведётся 8 бит и получившееся значение будет записано обратно. Это
		// приведёт к переключению всех выводов, соответствующие биты которых были равны "1".
		// Примечание: при чтении этот регистр возвращает ровно значение, которое было в него записано в предыдущий раз.
        GPIOA->DATAOUTTGL = (1 << 13);

#endif

#ifdef TOGGLE_BY_DATA
        //Алгоритм 4 (нужно раскомментировать макрос TOGGLE_BY_DATA в начале файла, и закомментировать остальные)
        // Прямое изменение регистра состояния выводов. Такой способ управления является нежелательным. Пояснение:
        //Предположим, используются подряд две команды вида NT_GPIOC->DATA &= ~(1 << 2) и NT_GPIOC->DATA |= (1 << 2). При изменении
        //регистра DATA порты меняют состояние не сразу, а через 2 такта (это связано с синхронизацией). Если
        //подряд написать 2 строчки, например NT_GPIOC->DATA &= ~(1 << 2) и NT_GPIOC->DATA &= ~(1 << 13), то первая
        //с большой вероятностью не сработает, так как доступ к биту осуществляется сначала чтением всего слова, изменением нужного
        //бита и записью его назад. Но чтение из GPIO возвращает текущее состояние порта, и к моменту выполнения второй команды (второй строки Си)
        //прочитанное состояние не будет содержать изменений, которые сделала первая команда, поэтому вторая команда затрет тот бит,
        //который хотела выставить первая команда.
        //При этом проблема проявляется только при включенной высокой оптимизации компилятора. Без оптимизации компилятор генерирует
        //достаточно много ассемблерных команд между обращениями к GPIO и синхронизация успевает выполниться.

        // Однако в данном конкретном примере изменяется состояние только одного вывода, поэтому проблем не возникнет.
        if (ledState == 0x1)
            GPIOA->DATA &= ~(1 << 13);
        else
            GPIOA->DATA |= (1 << 13);
#endif


	}

	timer++;
}


int16 main (void){
	//Инициализация микроконтроллера: настройка таймеров, инициализаци периферийных устройств
    SystemInit();

	//Инициализация периферии для управления диодами
	LED_init();

	//бесконечный цикл
	while(1)
	{
		LED_blink();	//мигание диодами
	}
}

/*@}*/


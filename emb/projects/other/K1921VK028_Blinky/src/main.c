/******************************************************************************
 * @file		main.c
 * @brief		Главный файл проекта
 * @version		v1.0
 * @date		25 июля 2019
 *
 * @note
 * ООО "НПФ Вектор" (http://motorcontrol.ru), все права защищены.
 *
 * @par
 * ООО "НПФ Вектор" распространяет это программное обеспечение в демонстрационных
 * целях, и оно может распространяться свободно.
 *
 * @par
 * Данное программное обеспечение распространяется "как есть", и Вы,
 * его пользователь, принимаете на себя все риски, связанные с его использованием.
 * ООО "НПФ Вектор" не несет никакой ответственности за возможные убытки,
 * связанные с его использованием.
 *
 ******************************************************************************/

//В этом примере показана работа с дискретными ножками микроконтроллера.
//Вначале производится инициализация нож для работы в режиме дискретного вывода.
//Затем программа попадает в бесконечный цикл, где с задержкой, задаваемой в переменной TimerPeriod,
//по одному из алгоритмов включаются и выключаются 6 светодиодов.
//Описаны некоторые "подводные камни" при работе с регистрами периферии.

#include "main.h"

// Макросы для выбора способа переключения светодиода (нужно раскомментировать один из них)
#define TOGGLE_BY_MASK              0
//#define TOGGLE_BY_DATAOUTSET_CLR    1
//#define TOGGLE_BY_DATATOGGLE        2
//#define TOGGLE_BY_DATA              3

//Глобальная переменная периода счета таймера (может быть изменена при остановке расчета в окне просмотра переменных)
int TimerPeriod = 500000;

// Глобальная переменная для хранения состояния светодиода
int ledState = 0;


//Функция инициализации дискретных выходов микроконтроллера для управления светодиодами
void LED_init (void)
{
	// На плате MotorControlBoard_028 имеются два светодиода, которые подключен к выводам 14 и 15 порта K микроконтроллера
    // К моменту вызова этой функции в данной программе выводы не функционирует. Чтобы настроить их для работы в качестве
    // управляемых выводов нужно сделать следующее
    // 1) Включить тактирование порта K блока GPIO записью "1" в соответствующий бит регистра HCLKCFG
    // 2) Вывести порт из состояния сброса записью "1" в соответствующий бит регистра HRSTCFG
    // 3) Разрешить его работу, записав "1" в соответствующий бит (бит №8) регистра DENSET. После этого вывод начнёт функционировать.
    //    по умолчанию в соответствии с документации он играет роль ввода-вывода общего назначения (управляется программой, а не
    //    каким-либо периферийным устройством) и настроен на _приём_ сигнала, а не на выдачу
    // 4) Вывод A8 переводится в режим _выдачи_ сигналов записью "1" в соответствующий бит регстра OUTENSET. По умолчанию, значение
    //    выхода равно "0", поэтому вывод А8 примет состояние "0".
    RCU->HCLKCFG_bit.GPIOKEN = 1;
    RCU->HRSTCFG_bit.GPIOKEN = 1;

    GPIOK->DENSET = (1 << 14);
	GPIOK->OUTENSET = (1 << 14);
	GPIOK->DENSET = (1 << 15);
    GPIOK->OUTENSET = (1 << 15);
}



//Функция мигания светодиодами
void LED_blink (void) {
	static int timer;	//переменная таймера

	if (timer > TimerPeriod)
	{
		timer = 0;
		ledState ^= 0x1;

#ifdef TOGGLE_BY_MASK
		// Способ 1. Обращение к GPIO по маске (см. документацию): MASKLOWBYTE - к младшему байту регистра, MASKHIGHBYTE - к старшему.
		//Допустим, мы хотим выдать "1" на GPIO2, GPIO3 и GPIO4 порта C:
		//0001 1100     маска, является индексом в массиве MASKLOWBYTE
		//xxx1 11xx     записываемое значение: в нужных битах - единицы, в остальных - не важно, т.к. они не попадают в маску и не будут изменены
		//NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 28;    так выглядит код команды, как вариант: NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 0xFF;
		//если надо включить GPIO2 и GPIO4 и выключить GPIO3, то:
		//NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 20;    20 = 0001 0100b
		//Доступ к битам порта по маске гарантирует, что другие биты, которые не попадают в маску, будут не затронуты.
		//Также доступ по маске позволяет одновременно одной командой переключить два бита порта, если это требуется.
		// В данном примере маска равна 192 (-> 1100 0000) и записывается в регистр MASKHB (High Byte) что соответствует
		// выводам 14 и 15
		if (ledState == 0x1){
		    GPIOK->MASKHB[192].MASKHB = 0xFF << 8;
		} else {
		    GPIOK->MASKHB[192].MASKHB = 0;
		}

#endif

#ifdef TOGGLE_BY_DATAOUTSET_CLR
		//Способ 2 (нужно раскомментировать макрос TOGGLE_BY_DATAOUTSET_CLR в начале файла, и закомментировать остальные)
		// После записи "1" в один из битов регистра DATAOUTSET, соответствующая ножка принимает состояние "1", независимо
		// от предыдущего состояния.
        // После записи "1" в один из битов регистра DATAOUTCLR, соответствующая ножка принимает состояние "0", независимо
        // от предыдущего состояния.
		// Важное примечание: при чтении эти регистры возвращают то значение, которое было записано в предыдущий раз.
        // Поэтому в те биты, которые НЕ должны менять своё состояние, обязательно нужно записать нули. То есть запись через
        // операцию побитового ИЛИ (например DATAOUTSET |= (1 << 8) ) недопустима, так как при этом будет считано значение
        // регистра DATAOUTSET, в прочитанном значении будет взведётся 8 бит и получившееся значение будет записано обратно. Это
        // приведёт к включению всех выводов, соответствующие биты которых были равны "1". Аналогично для DATAOUTCLR.
		// Пример:
		// При старте программы регистр DATAOUTSET равен "0000 0000 0000 0000"
		// В каком-то месте программы  был включен 4 вывод командой DATAOUTSET |= (1 << 4): прочитано значение "0000 0000 0000 0000",
		// изменён 4 бит, получившееся значение записано обратно. Теперь DATAOUTSET равен "0000 0000 0001 0000".
		// Затем вывод был выключен командой DATAOUTCLR |= (1 << 4).
		// Значение регистра DATAOUTSET при этом не изменилось: DATAOUTSET равен "0000 0000 0001 0000"
		// Затем пользователь захотел включить 8 вывод порта командой DATAOUTSET |= (1 << 8).
		// Теперь после чтения DATAOUTSET и изменения 8 бита, в него будет записано значение "0000 0001 0001 0000", что
		// приведёт к включению и 4, и 8 выводов.
		if (ledState == 0x1) {
		    GPIOK->DATAOUTSET = (1 << 14);
		    GPIOK->DATAOUTSET = (1 << 15);
		} else {
		    GPIOK->DATAOUTCLR = (1 << 14);
		    GPIOK->DATAOUTCLR = (1 << 15);
		}

#endif

#ifdef TOGGLE_BY_DATATOGGLE
        //Алгоритм 3 (нужно раскомментировать макрос TOGGLE_BY_DATATOGGLE в начале файла, и закомментировать остальные)
        // Запись "1" в один из битов регистра DATAOUTTGL меняет состояние соответсвующих ножек на противоположное.
		// При этом в те биты, которые НЕ должны переключаться, обязательно нужно записать нули. То есть запись через
		// операцию побитового ИЛИ (например DATAOUTTGL |= (1 << 8) ) недопустима, так как при этом будет считано значение
		// регистра TGL, в прочитанном значении будет взведётся 8 бит и получившееся значение будет записано обратно. Это
		// приведёт к переключению всех выводов, соответствующие биты которых были равны "1".
		// Примечание: при чтении этот регистр возвращает ровно значение, которое было в него записано в предыдущий раз.
        GPIOK->DATAOUTTGL = (1 << 14);
        GPIOK->DATAOUTTGL = (1 << 15);

#endif

#ifdef TOGGLE_BY_DATA
        //Алгоритм 4 (нужно раскомментировать макрос TOGGLE_BY_DATA в начале файла, и закомментировать остальные)
        // Прямое изменение регистра состояния выводов. Такой способ управления является нежелательным. Пояснение:
        //Предположим, используются подряд две команды вида NT_GPIOK->DATA &= ~(1 << 14) и GPIOK->DATA |= (1 << 15). При изменении
        //регистра DATA порты меняют состояние не сразу, а через 2 такта (это связано с синхронизацией). Если
        //подряд написать 2 строчки, например GPIOK->DATA &= ~(1 << 14) и GPIOK->DATA &= ~(1 << 15), то первая
        //с большой вероятностью не сработает, так как доступ к биту осуществляется сначала чтением всего слова, изменением нужного
        //бита и записью его назад. Но чтение из GPIO возвращает текущее состояние порта, и к моменту выполнения второй команды (второй строки Си)
        //прочитанное состояние не будет содержать изменений, которые сделала первая команда, поэтому вторая команда затрет тот бит,
        //который хотела выставить первая команда.
        //При этом проблема проявляется только при включенной высокой оптимизации компилятора. Без оптимизации компилятор генерирует
        //достаточно много ассемблерных команд между обращениями к GPIO и синхронизация успевает выполниться.

        if (ledState == 0x1){
            GPIOK->DATAOUT &= ~(1 << 14);
            GPIOK->DATAOUT &= ~(1 << 15);
        } else {
            GPIOK->DATAOUT |= (1 << 14);
            GPIOK->DATAOUT |= (1 << 15);
        }
#endif


	}

	timer++;
}


int16 main (void){
	//Инициализация микроконтроллера: настройка таймеров, инициализаци периферийных устройств
    SystemInit();

	//Инициализация периферии для управления диодами
	LED_init();

	//бесконечный цикл
	while(1)
	{
		LED_blink();	//мигание диодами
	}
}

/*@}*/


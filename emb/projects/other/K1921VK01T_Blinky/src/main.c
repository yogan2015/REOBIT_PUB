/******************************************************************************
 * @file		main.c
 * @brief		Главный файл проекта
 * @version		v1.0
 * @date		11 декабря 2015
 *
 * @note
 * ООО "НПФ Вектор" (http://motorcontrol.ru), все права защищены.
 *
 * @par
 * ООО "НПФ Вектор" распространяет это программное обеспечение в демонстрационных
 * целях, и оно может распространяться свободно.
 *
 * @par
 * Данное программное обеспечение распространяется "как есть", и Вы,
 * его пользователь, принимаете на себя все риски, связанные с его использованием.
 * ООО "НПФ Вектор" не несет никакой ответственности за возможные убытки,
 * связанные с его использованием.
 *
 ******************************************************************************/

//В этом примере показана работа с дискретными ножками микроконтроллера.
//Вначале производится инициализация ножек для работы в режиме дискретного вывода.
//Затем программа попадает в бесконечный цикл, где с задержкой, задаваемой в переменной TimerPeriod,
//по одному из алгоритмов включаются и выключаются 6 светодиодов.
//Описаны некоторые "подводные камни" при работе с регистрами периферии.

#include "main.h"


//Макросы для включения/выключения светодиодов на плате ControlCARD
//Можно использовать команды вида NT_GPIOC->DATA &= ~(1 << 2) и NT_GPIOC->DATA |= (1 << 2), но
//таким образом порты меняют состояние не сразу, а через 2 такта (это связано с синхронизацией), и, если
//подряд написать 2 строчки, например NT_GPIOC->DATA &= ~(1 << 2) и NT_GPIOC->DATA &= ~(1 << 3), то первая
//с большой вероятностью не сработает, так как доступ к биту осуществляется сначала чтением всего слова, изменением нужного
//бита и записью его назад. Но чтение из GPIO возвращает текущее состояние порта, и к моменту выполнения второй команды (второй строки Си)
//прочитанное состояние не будет содержать изменений, которые сделала первая команда, поэтому вторая команда затрет тот бит,
//который хотела выставить первая команда.
//При этом проблема проявляется только при включенной высокой оптимизации компилятора. Без оптимизации компилятор генерирует
//достаточно много ассемблерных команд между обращениями к GPIO и синхронизация успевает выполниться.

//Другой способ - обращение к GPIO по маске (см. документацию): MASKLOWBYTE - к младшему байту регистра, MASKHIGHBYTE - к старшему.
//Допустим, мы хотим выдать "1" на GPIO2, GPIO3 и GPIO4 порта C:
//0001 1100		маска, является индексом в массиве MASKLOWBYTE
//xxx1 11xx		записываемое значение: в нужных битах - единицы, в остальных - не важно, т.к. они не попадают в маску и не будут изменены
//NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 28;	так выглядит код команды, как вариант: NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 0xFF;
//если надо включить GPIO2 и GPIO4 и выключить GPIO3, то:
//NT_GPIOC->MASKLOWBYTE_bit[28].MASKLB = 20;	20 = 0001 0100b
//Доступ к битам порта по маске гарантирует, что другие биты, которые не попадают в маску, будут не затронуты.
//Также доступ по маске позволяет одновременно одной командой переключить два бита порта, если это требуется.

#define VD1_ON NT_GPIOC->MASKLOWBYTE_bit[8].MASKLB = 0			//NT_GPIOC->DATA &= ~(1 << 3)
#define VD1_OFF NT_GPIOC->MASKLOWBYTE_bit[8].MASKLB = 8			//NT_GPIOC->DATA |= (1 << 3)

#define VD2_ON NT_GPIOC->MASKLOWBYTE_bit[4].MASKLB = 0			//NT_GPIOC->DATA &= ~(1 << 2)
#define VD2_OFF NT_GPIOC->MASKLOWBYTE_bit[4].MASKLB = 4			//NT_GPIOC->DATA |= (1 << 2)

#define VD3_ON NT_GPIOB->MASKLOWBYTE_bit[32].MASKLB = 0			//NT_GPIOB->DATA &= ~(1 << 5)
#define VD3_OFF NT_GPIOB->MASKLOWBYTE_bit[32].MASKLB = 32		//NT_GPIOB->DATA |= (1 << 5)

#define VD4_ON NT_GPIOB->MASKLOWBYTE_bit[64].MASKLB = 0			//NT_GPIOB->DATA &= ~(1 << 6)
#define VD4_OFF NT_GPIOB->MASKLOWBYTE_bit[64].MASKLB = 64		//NT_GPIOB->DATA |= (1 << 6)

#define VD5_ON NT_GPIOB->MASKLOWBYTE_bit[128].MASKLB = 0		//NT_GPIOB->DATA &= ~(1 << 7)
#define VD5_OFF NT_GPIOB->MASKLOWBYTE_bit[128].MASKLB = 128		//NT_GPIOB->DATA |= (1 << 7)

#define VD6_ON NT_GPIOB->MASKHIGHBYTE_bit[1].MASKHB = 0			//NT_GPIOB->DATA &= ~(1 << 8)
#define VD6_OFF NT_GPIOB->MASKHIGHBYTE_bit[1].MASKHB = 1		//NT_GPIOB->DATA |= (1 << 8)

//Глобальная переменная периода счета таймера (может быть изменена при остановке расчета в окне просмотра переменных)
int TimerPeriod = 500000;


//Функция инициализации дискретных выходов микроконтроллера для управления светодиодами
void LED_init (void)
{
	//Для каждой дискретной ножки нужно:
	//1)Выключить привязанные к этой ножке спецфункции путем сброса соответствующего бита в регистре спецфункций порта.
	//Для сброса бита нужно записать "1" в соответствующий бит регистра ALTFUNCCLR (CLR - clear - очистить).
	//Если нужно наоборот включить спецфункцию, то следует записать "1" в соответствующий бит регистра ALTFUNCSET (SET - установить).
	//Прочитать текущее состояние регистра спецфункций порта можно, прочитав любой из двух регистров ALTFUNCCLR или ALTFUNCSET.
	//2)Разрешить ножке работать на вывод путем записи "1" в соответствующий бит регистра OUTENSET.
	NT_GPIOC->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 2);
	NT_GPIOC->OUTENSET_bit.OUTENSET |= (1 << 2);
	NT_GPIOC->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 3);
	NT_GPIOC->OUTENSET_bit.OUTENSET |= (1 << 3);
	NT_GPIOB->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 5);
	NT_GPIOB->OUTENSET_bit.OUTENSET |= (1 << 5);
	NT_GPIOB->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 6);
	NT_GPIOB->OUTENSET_bit.OUTENSET |= (1 << 6);
	NT_GPIOB->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 7);
	NT_GPIOB->OUTENSET_bit.OUTENSET |= (1 << 7);
	NT_GPIOB->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 8);
	NT_GPIOB->OUTENSET_bit.OUTENSET |= (1 << 8);

	//Почему команды NT_GPIOC->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 2); и NT_GPIOC->OUTENSET_bit.OUTENSET |= (1 << 2); отличаются,
	//ведь они выполняют по сути одну и ту же операцию: изменение 2-го бита (если считать от нуля) в регистре?
	//Дело в том, что для записи одного бита в регистр он сначала читается целиком,
	//затем выставляется "1" во втором бите, остальные не меняются, и регистр записывается обратно целиком.
	//По команде ALTFUNCCLR = (1 << 2) в регистр будут записаны все нули и "1" во втором бите.
	//Разница состоит в том, что при чтении регистров OUTENSET и ALTFUNCCLR "1" и там и там означет включенную
	//работу ножки на вывод или альтернативную функцию, соответственно. НО! При записи "1" в OUTENSET происходит включение
	//ножки на вывод, а в ALTFUNCCLR - вЫключение альт. функции. Рассмотрим пример:
	//NT_GPIOC->OUTENSET_bit.OUTENSET |= (1 << 7);
	//0000 1100 0000 1111			исходное состояние: пусть были включены на вывод ножки 0-3 и 10-11
	//0000 1100 0000 1111			чтение регистра целиком
	//0000 1100 1000 1111			добавление "1" в 7-й бит
	//0000 1100 1000 1111			запись регистра целиком
	//0000 1100 1000 1111			результат: включены все ножки, что и в исходном состоянии + 7-я, как и требовалось
	//NT_GPIOC->ALTFUNCCLR_bit.ALTFUNCCLR |= (1 << 7);
	//0000 1100 1000 1111			исходное состояние: пусть были включены альт. функции ножек 0-3, 7 и 10-11
	//0000 1100 1000 1111			чтение регистра целиком
	//0000 1100 1000 1111			добавление "1" в 7-й бит (т.к. альт. функция была включена, состояние регистра не изменилось)
	//0000 1100 1000 1111			запись регистра целиком
	//0000 0000 0000 0000			результат: выключены все ножки, т.к. при чтении "1" означает включенное состояние, а при записи "1" означает команду "выключить"
	//NT_GPIOC->ALTFUNCCLR_bit.ALTFUNCCLR = (1 << 7);	чтобы добиться желаемого результата, нужно записать "1" только в 7-й бит и "0" - во все остальные:
	//0000 1100 1000 1111			исходное состояние: пусть были включены альт. функции ножек 0-3, 7 и 10-11
	//0000 1100 1000 1111			чтение регистра целиком
	//0000 0000 1000 0000			запись "1" в 7-й бит и "0" в остальные
	//0000 0000 1000 0000			запись регистра целиком
	//0000 1100 0000 1111			результат: выключена только требуемая ножка, как и требовалось
	//Аналогичная ситуация может быть и с остальными регистрами типа SET и CLR. Подробнее - см. документацию на микроконтроллер, как
	//работают соответствующие регистры на чтение.
}


//Функция мигания светодиодами
void LED_blink (void)
{
	static int timer;	//переменная таймера
	static int LEDs;	//переменная состояния светодиодов

	if (timer > TimerPeriod)
	{
		timer = 0;
		LEDs++;
		LEDs &= 0x3F;

		//Алгоритм 1
		if (LEDs & (1<<5))
			VD1_ON;
		else
			VD1_OFF;

		if (LEDs & (1<<4))
			VD2_ON;
		else
			VD2_OFF;

		if (LEDs & (1<<3))
			VD3_ON;
		else
			VD3_OFF;

		if (LEDs & (1<<2))
			VD4_ON;
		else
			VD4_OFF;

		if (LEDs & (1<<1))
			VD5_ON;
		else
			VD5_OFF;

		if (LEDs & (1<<0))
			VD6_ON;
		else
			VD6_OFF;

		//Алгоритм 2 (нужно закомментировать первый алгоритм, раскомментировать второй и включить оптимизацию для проекта -O3)
		//Для иллюстрации того, что при обращении через регистр DATA дискретные ножки могут работать неправильно,
		//будем включать и выключать их одновременно. Если включить оптимизацию кода и ускорить таким образом
		//его выполнение, можно увидеть, что диоды загораются неправильно.
		/*if (LEDs > 31)
		{
			NT_GPIOC->DATA &= ~(1 << 2);
			NT_GPIOC->DATA &= ~(1 << 3);
			NT_GPIOB->DATA &= ~(1 << 5);
			NT_GPIOB->DATA &= ~(1 << 6);
			NT_GPIOB->DATA &= ~(1 << 7);
			NT_GPIOB->DATA &= ~(1 << 8);
		}
		else
		{
			NT_GPIOC->DATA |= (1 << 2);
			NT_GPIOC->DATA |= (1 << 3);
			NT_GPIOB->DATA |= (1 << 5);
			NT_GPIOB->DATA |= (1 << 6);
			NT_GPIOB->DATA |= (1 << 7);
			NT_GPIOB->DATA |= (1 << 8);
		}*/
	}

	timer++;
}


int16 main (void){
	//Инициализация микроконтроллера: настройка таймеров, инициализаци периферийных устройств
	InitCLK();

	//Инициализация периферии для управления диодами
	LED_init();

	//бесконечный цикл
	while(1)
	{
		LED_blink();	//мигание диодами
	}
}

/*@}*/

